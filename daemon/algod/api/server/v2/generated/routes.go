// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
