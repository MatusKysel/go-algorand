// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
